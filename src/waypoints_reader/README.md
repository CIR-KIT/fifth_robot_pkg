## 前置き
現状使おうとしている navigation の設定パラメータ変更
[参考url](http://wiki.ros.org/ja/turtlebot_navigation/Tutorials/Setup%20the%20Navigation%20Stack%20for%20TurtleBot)
がどの程度走行特性に影響するかによっては, 以下に記す事柄は不要となる可能性がある.

## Guidance
PyYAML-3.05 をインストールしています.
実行環境は Ubuntu 16.04 標準の Python 2.7.12 ですが. 可搬性を考えてこのまま.
環境設定は
wget http://pyyaml.org/download/pyyaml/PyYAML-3.05.tar.gz
tar xzf PyYAML-3.05.tar.gz
cd PyYAML-3.05/
sudo python setup.py install

でよいでしょう.

## 位置づけ
今から作ろうとするものは,
- ファイルに記録した waypoint より参照した点を認識
- waypoint から goal を生成する
- goal を navigation へ渡す

## 概説
一番簡単なのは, マップ上での自己位置推定と( /amcl からの /base\_link), waypoint とを比較してキューにためた waypoint データをpopしていくことになるのだが,
goal が結局通過点なのか到達点なのかがわかっていないことが問題として残る.
これを改善する方法は大まかに 2 パターンあるはず.

### goal 以外のパラメータを作る
- 外部的判断を挟んでgoalを偽造するラッパーを作る.( ここで, goal は実際の目的地, ゴールには成り得ない. waypoint と odom から動的に再生成され続ける一時的な目標地点へと成り下がっている.)
 + waypoint データに局所的な通過上限/下限速度の欄を設けておく
 + waypoint データを複数キャッシュして, そこから導き出される角度的な変位から制限速度を設ける
    * cmd\_vel を, cmd\_vel\_mod とかに読み替えてドライバに渡す

 + navigation へgoal以外を渡して処理できるように関連する node たちを改造する (なおコスト)

前者は内部的な処理, 特に局所的コストマップ周辺について navigation の内部的な判断が効かなくなる問題があり,実際そのあたりにまた改造がいる.

### goal を動的に再設定し直し続ける

ある条件下*1 で goal を再設定し, 
goal を少しずつずらしていくパターンを作成することを可能にしておく.

*1 条件下: 大域プランによって順調に走行できている時.(障害物回避行動を取っていない, コストマップのデッドロックが発生していない, なおかつ waypoint に接近しつつある, etcetc...) 

→ そのパターン変移条件を waypoint の性格付けにすることもできるし, より複雑な走行パターン指定のためのパラメータ追加も可能となる.

今のところ自分は後者の考えが図抜けて簡単で効果的だと思っている.

## 具体的設計(草案)
- 以下のガイドに従った, yaml ファイルを書く.
 + waypoint\_number
 + waypoint\_name (オプション)
 + 地図内の座標系における waypoint の x
 + 地図内の座標系における waypoint の y
 + 重要性
    * waypoint が通過点なのか目的地点なのか指定する.
 + 許容半径
    * 要求する正確性を_ローカルに_指定する. (navigationで指定するものとは別.)
 + 粘性抵抗係数
    * 急速な機動を制限していく. 安全走行が必要なところで高める.
 + まだあるかな?

- プログラム側でやること

 + yaml ファイルを読み込む
 + amcl からの 自己位置推定値を受け取る.
 + 現在の走行状況を確認する.
    * topic 監視により rotate\_recovery が stuck (行き止まり対処)してないか判定.
 + 自己位置推定値と, waypoint との距離, 角度, 対象 waypoint の属性を見る
 + 計算し,goal を渡す.

## 計算とは
* 次の waypoint が通過点である場合
 - 現在地点から進行方向に引いた直線を始線として, 次の waypoint と 現在地及び 次の次の waypoint と 現在地とをつないだ線分のなす角の様子を見る.
 - 仮経路計算: (例えば) 上で出したの角の相加平均をとって, 仮の進行方向を取る,
 - 仮の進行方向を検証する. つまるところ, そのとおりに進んだとして waypoint 許容半径内に到達するかを検証する. 
 - 仮の進行方向を許容半径側に寄せて訂正する.
 - 進行する.
 - 許容半径内座標に到達したら, goal は次の waypoint を指向する. ただし, goal の変更は粘性抵抗係数に制限されて穏やかに変更される.
* 次の waypoint が到達点である場合
 - waypoint = goal を指定する.
 - 終端動作をかける: 減速して, waypoint = goal に到達する.(これは navigation  に任せる.)

## なにこれ
 終端動作(減速, 過剰な寄せetc)をできるだけ行わないようにすることがこのプログラムの目的. こうすれば waypoint に到達することは無い-付近で減速する,止まることは無いし, 通過点は通過点として, 余計な終端動作を省略して通り過ぎることができる上,  waypoint を容赦なく増量していくこともできる.
